# -*- coding: utf-8 -*-
"""DL EXP-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tPVAuNm14OiamkPdZU3jpZ-a0CymP7Mi
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

x=torch.linspace(1,50,50).reshape(-1,1)

torch.manual_seed(71)

e=torch.randint(-8,9,(50,1),dtype=torch.float32)

print(e.sum())

"""Arikatla Hari Veera Prasad
212223240014
"""

y = 2*x + 1 + e
print(y.shape)

plt.scatter(x.numpy(), y.numpy(),color='red')  # Scatter plot of data points
plt.xlabel('x')
plt.ylabel('y')
plt.title('Generated Data for Linear Regression')
plt.show()

# Setting a manual seed for reproducibility
torch.manual_seed(59)

# Defining the model class
model = nn.Linear(1, 1)  # Linear regression model with 1 input and 1 output

# Accessing weight and bias directly
print('Weight:', model.weight.item())
print('Bias:  ', model.bias.item())

loss_function = nn.MSELoss()  # Mean Squared Error (MSE) loss

optimizer = torch.optim.SGD(model.parameters(), lr=0.001)  # Stochastic Gradient Descent

epochs = 50  # Number of training iterations
losses = []  # List to store loss values

for epoch in range(1, epochs + 1):  # Start from 1 to 50
    optimizer.zero_grad()  # Clear previous gradients
    y_pred = model(x)  # Forward pass
    loss = loss_function(y_pred, y)  # Compute loss
    losses.append(loss.item())  # Store loss value

    loss.backward()  # Compute gradients
    optimizer.step()  # Update weights

    # Print loss, weight, and bias for EVERY epoch (1 to 50)
    print(f'epoch: {epoch:2}  loss: {loss.item():10.8f}  '
          f'weight: {model.weight.item():10.8f}  '
          f'bias: {model.bias.item():10.8f}')

plt.plot(range(epochs), losses)
plt.ylabel('Loss')
plt.xlabel('epoch');
plt.show()

# Automatically determine x-range
x1 = torch.tensor([x.min().item(), x.max().item()])

# Extract model parameters
w1, b1 = model.weight.item(), model.bias.item()

# Compute y1 (predicted values)
y1 = x1 * w1 + b1

# Print weight, bias, and x/y values
print(f'Final Weight: {w1:.8f}, Final Bias: {b1:.8f}')
print(f'X range: {x1.numpy()}')
print(f'Predicted Y values: {y1.numpy()}')

# Plot original data and best-fit line
plt.scatter(x.numpy(), y.numpy(), label="Original Data")
plt.plot(x1.numpy(), y1.numpy(), 'r', label="Best-Fit Line")
plt.xlabel('x')
plt.ylabel('y')
plt.title('Trained Model: Best-Fit Line')
plt.legend()
plt.show()

torch.save(model.state_dict(), 'linear_regression_model.pth')
print('Model saved successfully.')

